$include_const 'datatypes.pasm';

function load[anon,load]() {
  load_bytecode('def.pbc');
}

function gmpz_t[anon, immediate]() {
  var gmpz_t = new 'StructView'([ DATATYPE_STRUCT, 3, DATATYPE_INT, DATATYPE_PTR, DATATYPE_INT ]);
  return gmpz_t;
}

namespace GMP {
  class Integer {
    var ptr;

    function Integer() {
      using static gmpz_t;
      var ptr = self.ptr = gmpz_t.alloc();
      using gmp.__gmpz_init;
      __gmpz_init(ptr);
    }

    function destroy[vtable('destroy')]() {
      if(self.ptr != null) {
        var ptr  = self.ptr;
        self.ptr = null;
        using gmp.__gmpz_clear;
        __gmpz_clear(ptr);
      }
    }
  }
}

/*
=head1 void mpz_init (mpz_t x)

Initialize x, and set its value to 0. 

=cut
*/

function mpz_init (var x) {
  if(!(x instanceof GMP.Integer))
    die("incorrect type for x in mpz_init");
  using gmp.__gmpz_init;
   __gmpz_init(x);
}

/*
=head1 void mpz_init2 (mpz_t x, mp_bitcnt_t n)

Initialize x, with space for n-bit numbers, and set its value to 0. Calling this function instead of mpz_init or mpz_inits is never necessary; reallocation is handled automatically by GMP when needed. n is only the initial space, x will grow automatically in the normal way, if necessary, for subsequent values stored. mpz_init2 makes it possible to avoid such reallocations if a maximum size is known in advance. 

=cut
*/

function mpz_init2 (var x, int n) {
  if(!(x instanceof GMP.Integer))
    die("incorrect type for x in mpz_init2");
  using gmp.__gmpz_init2;
   __gmpz_init2(x, n);
}

/*
=head1 void mpz_clear (mpz_t x)

Free the space occupied by x. Call this function for all mpz_t variables when you are done with them. 

=cut
*/

function mpz_clear (var x) {
  if(!(x instanceof GMP.Integer))
    die("incorrect type for x in mpz_clear");
  using gmp.__gmpz_clear;
   __gmpz_clear(x);
}

/*
=head1 void mpz_realloc2 (mpz_t x, mp_bitcnt_t n)

Change the space allocated for x to n bits. The value in x is preserved if it fits, or is set to 0 if not. Calling this function is never necessary; reallocation is handled automatically by GMP when needed. But this function can be used to increase the space for a variable in order to avoid repeated automatic reallocations, or to decrease it to give memory back to the heap. 

=cut
*/

function mpz_realloc2 (var x, int n) {
  if(!(x instanceof GMP.Integer))
    die("incorrect type for x in mpz_realloc2");
  using gmp.__gmpz_realloc2;
   __gmpz_realloc2(x, n);
}

/*
=head1 void mpz_set (mpz_t rop, mpz_t op)

=head1 void mpz_set_ui (mpz_t rop, unsigned long int op)

=head1 void mpz_set_si (mpz_t rop, signed long int op)

=head1 void mpz_set_d (mpz_t rop, double op)

Set the value of rop from op. mpz_set_d, mpz_set_q and mpz_set_f truncate op to make it an integer. 

=cut
*/

function mpz_set (var rop, var op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_set");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_set");
  using gmp.__gmpz_set;
   __gmpz_set(rop, op);
}

function mpz_set_ui (var rop, int op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_set_ui");
  using gmp.__gmpz_set_ui;
   __gmpz_set_ui(rop, op);
}

function mpz_set_si (var rop, int op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_set_si");
  using gmp.__gmpz_set_si;
   __gmpz_set_si(rop, op);
}

function mpz_set_d (var rop, float op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_set_d");
  using gmp.__gmpz_set_d;
   __gmpz_set_d(rop, op);
}

/*
=head1 int mpz_set_str (mpz_t rop, char * str, int base)

Set the value of rop from str, a null-terminated C string in base base. White space is allowed in the string, and is simply ignored. The base may vary from 2 to 62, or if base is 0, then the leading characters are used: 0x and 0X for hexadecimal, 0b and 0B for binary, 0 for octal, or decimal otherwise. For bases up to 36, case is ignored; upper-case and lower-case letters have the same value. For bases 37 to 62, upper-case letter represent the usual 10..35 while lower-case letter represent 36..61. This function returns 0 if the entire string is a valid number in base base. Otherwise it returns -1. 

=cut
*/

function mpz_set_str (var rop, var str, int base) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_set_str");
  using gmp.__gmpz_set_str;
  return __gmpz_set_str(rop, str, base);
}

/*
=head1 void mpz_swap (mpz_t rop1, mpz_t rop2)

Swap the values rop1 and rop2 efficiently. 

=cut
*/

function mpz_swap (var rop1, var rop2) {
  if(!(rop1 instanceof GMP.Integer))
    die("incorrect type for rop1 in mpz_swap");
  if(!(rop2 instanceof GMP.Integer))
    die("incorrect type for rop2 in mpz_swap");
  using gmp.__gmpz_swap;
   __gmpz_swap(rop1, rop2);
}

/*
=head1 void mpz_init_set (mpz_t rop, mpz_t op)

=head1 void mpz_init_set_ui (mpz_t rop, unsigned long int op)

=head1 void mpz_init_set_si (mpz_t rop, signed long int op)

=head1 void mpz_init_set_d (mpz_t rop, double op)

Initialize rop with limb space and set the initial numeric value from op. 

=cut
*/

function mpz_init_set (var rop, var op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_init_set");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_init_set");
  using gmp.__gmpz_init_set;
   __gmpz_init_set(rop, op);
}

function mpz_init_set_ui (var rop, int op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_init_set_ui");
  using gmp.__gmpz_init_set_ui;
   __gmpz_init_set_ui(rop, op);
}

function mpz_init_set_si (var rop, int op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_init_set_si");
  using gmp.__gmpz_init_set_si;
   __gmpz_init_set_si(rop, op);
}

function mpz_init_set_d (var rop, float op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_init_set_d");
  using gmp.__gmpz_init_set_d;
   __gmpz_init_set_d(rop, op);
}

/*
=head1 int mpz_init_set_str (mpz_t rop, char * str, int base)

Initialize rop and set its value like mpz_set_str (see its documentation above for details). If the string is a correct base base number, the function returns 0; if an error occurs it returns -1. rop is initialized even if an error occurs. (I.e., you have to call mpz_clear for it.) 

=cut
*/

function mpz_init_set_str (var rop, var str, int base) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_init_set_str");
  using gmp.__gmpz_init_set_str;
  return __gmpz_init_set_str(rop, str, base);
}

/*
=head1 unsigned long int mpz_get_ui (mpz_t op)

Return the value of op as an unsigned long. If op is too big to fit an unsigned long then just the least significant bits that do fit are returned. The sign of op is ignored, only the absolute value is used. 

=cut
*/

function mpz_get_ui (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_get_ui");
  using gmp.__gmpz_get_ui;
  return __gmpz_get_ui(op);
}

/*
=head1 signed long int mpz_get_si (mpz_t op)

If op fits into a signed long int return the value of op. Otherwise return the least significant part of op, with the same sign as op. If op is too big to fit in a signed long int, the returned result is probably not very useful. To find out if the value will fit, use the function mpz_fits_slong_p. 

=cut
*/

function mpz_get_si (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_get_si");
  using gmp.__gmpz_get_si;
  return __gmpz_get_si(op);
}

/*
=head1 double mpz_get_d (mpz_t op)

Convert op to a double, truncating if necessary (ie. rounding towards zero). If the exponent from the conversion is too big, the result is system dependent. An infinity is returned where available. A hardware overflow trap may or may not occur. 

=cut
*/

function mpz_get_d (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_get_d");
  using gmp.__gmpz_get_d;
  return __gmpz_get_d(op);
}

/*
=head1 double mpz_get_d_2exp (signed long int * exp, mpz_t op)

Convert op to a double, truncating if necessary (ie. rounding towards zero), and returning the exponent separately. The return value is in the range 0.5<=abs(d)<1 and the exponent is stored to *exp. d * 2^exp is the (truncated) op value. If op is zero, the return is 0.0 and 0 is stored to *exp. This is similar to the standard C frexp function (see Normalization Functions). 

=cut
*/

function mpz_get_d_2exp (var exp, var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_get_d_2exp");
  using gmp.__gmpz_get_d_2exp;
  return __gmpz_get_d_2exp(exp, op);
}

/*
=head1 char * mpz_get_str (char * str, int base, mpz_t op)

Convert op to a string of digits in base base. The base argument may vary from 2 to 62 or from -2 to -36. For base in the range 2..36, digits and lower-case letters are used; for -2..-36, digits and upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in that significance order) are used. If str is NULL, the result string is allocated using the current allocation function (see Custom Allocation). The block will be strlen(str)+1 bytes, that being exactly enough for the string and null-terminator. If str is not NULL, it should point to a block of storage large enough for the result, that being mpz_sizeinbase (op, base) + 2. The two extra bytes are for a possible minus sign, and the null-terminator. A pointer to the result string is returned, being either the allocated block, or the given str. 

=cut
*/

function mpz_get_str (var str, int base, var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_get_str");
  using gmp.__gmpz_get_str;
  return __gmpz_get_str(str, base, op);
}

/*
=head1 void mpz_add (mpz_t rop, mpz_t op1, mpz_t op2)

=head1 void mpz_add_ui (mpz_t rop, mpz_t op1, unsigned long int op2)

Set rop to op1 + op2. 

=cut
*/

function mpz_add (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_add");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_add");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_add");
  using gmp.__gmpz_add;
   __gmpz_add(rop, op1, op2);
}

function mpz_add_ui (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_add_ui");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_add_ui");
  using gmp.__gmpz_add_ui;
   __gmpz_add_ui(rop, op1, op2);
}

/*
=head1 void mpz_sub (mpz_t rop, mpz_t op1, mpz_t op2)

=head1 void mpz_sub_ui (mpz_t rop, mpz_t op1, unsigned long int op2)

=head1 void mpz_ui_sub (mpz_t rop, unsigned long int op1, mpz_t op2)

Set rop to op1 - op2. 

=cut
*/

function mpz_sub (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_sub");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_sub");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_sub");
  using gmp.__gmpz_sub;
   __gmpz_sub(rop, op1, op2);
}

function mpz_sub_ui (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_sub_ui");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_sub_ui");
  using gmp.__gmpz_sub_ui;
   __gmpz_sub_ui(rop, op1, op2);
}

function mpz_ui_sub (var rop, int op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_ui_sub");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_ui_sub");
  using gmp.__gmpz_ui_sub;
   __gmpz_ui_sub(rop, op1, op2);
}

/*
=head1 void mpz_mul (mpz_t rop, mpz_t op1, mpz_t op2)

=head1 void mpz_mul_si (mpz_t rop, mpz_t op1, long int op2)

=head1 void mpz_mul_ui (mpz_t rop, mpz_t op1, unsigned long int op2)

Set rop to op1 times op2. 

=cut
*/

function mpz_mul (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_mul");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_mul");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_mul");
  using gmp.__gmpz_mul;
   __gmpz_mul(rop, op1, op2);
}

function mpz_mul_si (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_mul_si");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_mul_si");
  using gmp.__gmpz_mul_si;
   __gmpz_mul_si(rop, op1, op2);
}

function mpz_mul_ui (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_mul_ui");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_mul_ui");
  using gmp.__gmpz_mul_ui;
   __gmpz_mul_ui(rop, op1, op2);
}

/*
=head1 void mpz_addmul (mpz_t rop, mpz_t op1, mpz_t op2)

=head1 void mpz_addmul_ui (mpz_t rop, mpz_t op1, unsigned long int op2)

Set rop to rop + op1 times op2. 

=cut
*/

function mpz_addmul (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_addmul");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_addmul");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_addmul");
  using gmp.__gmpz_addmul;
   __gmpz_addmul(rop, op1, op2);
}

function mpz_addmul_ui (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_addmul_ui");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_addmul_ui");
  using gmp.__gmpz_addmul_ui;
   __gmpz_addmul_ui(rop, op1, op2);
}

/*
=head1 void mpz_submul (mpz_t rop, mpz_t op1, mpz_t op2)

=head1 void mpz_submul_ui (mpz_t rop, mpz_t op1, unsigned long int op2)

Set rop to rop - op1 times op2. 

=cut
*/

function mpz_submul (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_submul");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_submul");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_submul");
  using gmp.__gmpz_submul;
   __gmpz_submul(rop, op1, op2);
}

function mpz_submul_ui (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_submul_ui");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_submul_ui");
  using gmp.__gmpz_submul_ui;
   __gmpz_submul_ui(rop, op1, op2);
}

/*
=head1 void mpz_mul_2exp (mpz_t rop, mpz_t op1, mp_bitcnt_t op2)

Set rop to op1 times 2 raised to op2. This operation can also be defined as a left shift by op2 bits. 

=cut
*/

function mpz_mul_2exp (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_mul_2exp");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_mul_2exp");
  using gmp.__gmpz_mul_2exp;
   __gmpz_mul_2exp(rop, op1, op2);
}

/*
=head1 void mpz_neg (mpz_t rop, mpz_t op)

Set rop to -op. 

=cut
*/

function mpz_neg (var rop, var op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_neg");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_neg");
  using gmp.__gmpz_neg;
   __gmpz_neg(rop, op);
}

/*
=head1 void mpz_abs (mpz_t rop, mpz_t op)

Set rop to the absolute value of op. 

=cut
*/

function mpz_abs (var rop, var op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_abs");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_abs");
  using gmp.__gmpz_abs;
   __gmpz_abs(rop, op);
}

/*
=head1 void mpz_cdiv_q (mpz_t q, mpz_t n, mpz_t d)

=head1 void mpz_cdiv_r (mpz_t r, mpz_t n, mpz_t d)

=head1 void mpz_cdiv_qr (mpz_t q, mpz_t r, mpz_t n, mpz_t d)

=head1 unsigned long int mpz_cdiv_q_ui (mpz_t q, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_cdiv_r_ui (mpz_t r, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_cdiv_qr_ui (mpz_t q, mpz_t r, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_cdiv_ui (mpz_t n, unsigned long int d)

=head1 void mpz_cdiv_q_2exp (mpz_t q, mpz_t n, mp_bitcnt_t b)

=head1 void mpz_cdiv_r_2exp (mpz_t r, mpz_t n, mp_bitcnt_t b)

=cut
*/

function mpz_cdiv_q (var q, var n, var d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_cdiv_q");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_q");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_cdiv_q");
  using gmp.__gmpz_cdiv_q;
   __gmpz_cdiv_q(q, n, d);
}

function mpz_cdiv_r (var r, var n, var d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_cdiv_r");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_r");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_cdiv_r");
  using gmp.__gmpz_cdiv_r;
   __gmpz_cdiv_r(r, n, d);
}

function mpz_cdiv_qr (var q, var r, var n, var d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_cdiv_qr");
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_cdiv_qr");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_qr");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_cdiv_qr");
  using gmp.__gmpz_cdiv_qr;
   __gmpz_cdiv_qr(q, r, n, d);
}

function mpz_cdiv_q_ui (var q, var n, int d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_cdiv_q_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_q_ui");
  using gmp.__gmpz_cdiv_q_ui;
  return __gmpz_cdiv_q_ui(q, n, d);
}

function mpz_cdiv_r_ui (var r, var n, int d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_cdiv_r_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_r_ui");
  using gmp.__gmpz_cdiv_r_ui;
  return __gmpz_cdiv_r_ui(r, n, d);
}

function mpz_cdiv_qr_ui (var q, var r, var n, int d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_cdiv_qr_ui");
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_cdiv_qr_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_qr_ui");
  using gmp.__gmpz_cdiv_qr_ui;
  return __gmpz_cdiv_qr_ui(q, r, n, d);
}

function mpz_cdiv_ui (var n, int d) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_ui");
  using gmp.__gmpz_cdiv_ui;
  return __gmpz_cdiv_ui(n, d);
}

function mpz_cdiv_q_2exp (var q, var n, int b) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_cdiv_q_2exp");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_q_2exp");
  using gmp.__gmpz_cdiv_q_2exp;
   __gmpz_cdiv_q_2exp(q, n, b);
}

function mpz_cdiv_r_2exp (var r, var n, int b) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_cdiv_r_2exp");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_cdiv_r_2exp");
  using gmp.__gmpz_cdiv_r_2exp;
   __gmpz_cdiv_r_2exp(r, n, b);
}

/*
=head1 void mpz_fdiv_q (mpz_t q, mpz_t n, mpz_t d)

=head1 void mpz_fdiv_r (mpz_t r, mpz_t n, mpz_t d)

=head1 void mpz_fdiv_qr (mpz_t q, mpz_t r, mpz_t n, mpz_t d)

=head1 unsigned long int mpz_fdiv_q_ui (mpz_t q, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_fdiv_r_ui (mpz_t r, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_fdiv_qr_ui (mpz_t q, mpz_t r, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_fdiv_ui (mpz_t n, unsigned long int d)

=head1 void mpz_fdiv_q_2exp (mpz_t q, mpz_t n, mp_bitcnt_t b)

=head1 void mpz_fdiv_r_2exp (mpz_t r, mpz_t n, mp_bitcnt_t b)

=cut
*/

function mpz_fdiv_q (var q, var n, var d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_fdiv_q");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_q");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_fdiv_q");
  using gmp.__gmpz_fdiv_q;
   __gmpz_fdiv_q(q, n, d);
}

function mpz_fdiv_r (var r, var n, var d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_fdiv_r");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_r");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_fdiv_r");
  using gmp.__gmpz_fdiv_r;
   __gmpz_fdiv_r(r, n, d);
}

function mpz_fdiv_qr (var q, var r, var n, var d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_fdiv_qr");
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_fdiv_qr");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_qr");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_fdiv_qr");
  using gmp.__gmpz_fdiv_qr;
   __gmpz_fdiv_qr(q, r, n, d);
}

function mpz_fdiv_q_ui (var q, var n, int d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_fdiv_q_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_q_ui");
  using gmp.__gmpz_fdiv_q_ui;
  return __gmpz_fdiv_q_ui(q, n, d);
}

function mpz_fdiv_r_ui (var r, var n, int d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_fdiv_r_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_r_ui");
  using gmp.__gmpz_fdiv_r_ui;
  return __gmpz_fdiv_r_ui(r, n, d);
}

function mpz_fdiv_qr_ui (var q, var r, var n, int d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_fdiv_qr_ui");
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_fdiv_qr_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_qr_ui");
  using gmp.__gmpz_fdiv_qr_ui;
  return __gmpz_fdiv_qr_ui(q, r, n, d);
}

function mpz_fdiv_ui (var n, int d) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_ui");
  using gmp.__gmpz_fdiv_ui;
  return __gmpz_fdiv_ui(n, d);
}

function mpz_fdiv_q_2exp (var q, var n, int b) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_fdiv_q_2exp");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_q_2exp");
  using gmp.__gmpz_fdiv_q_2exp;
   __gmpz_fdiv_q_2exp(q, n, b);
}

function mpz_fdiv_r_2exp (var r, var n, int b) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_fdiv_r_2exp");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_fdiv_r_2exp");
  using gmp.__gmpz_fdiv_r_2exp;
   __gmpz_fdiv_r_2exp(r, n, b);
}

/*
=head1 void mpz_tdiv_q (mpz_t q, mpz_t n, mpz_t d)

=head1 void mpz_tdiv_r (mpz_t r, mpz_t n, mpz_t d)

=head1 void mpz_tdiv_qr (mpz_t q, mpz_t r, mpz_t n, mpz_t d)

=head1 unsigned long int mpz_tdiv_q_ui (mpz_t q, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_tdiv_r_ui (mpz_t r, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_tdiv_qr_ui (mpz_t q, mpz_t r, mpz_t n, unsigned long int d)

=head1 unsigned long int mpz_tdiv_ui (mpz_t n, unsigned long int d)

=head1 void mpz_tdiv_q_2exp (mpz_t q, mpz_t n, mp_bitcnt_t b)

=head1 void mpz_tdiv_r_2exp (mpz_t r, mpz_t n, mp_bitcnt_t b)

 
     
      Divide n by d, forming a quotient q and/or remainder r. For the 2exp functions, d=2^b. The rounding is in three styles, each suiting different applications. cdiv rounds q up towards +infinity, and r will have the opposite sign to d. The c stands for "ceil". fdiv rounds q down towards -infinity, and r will have the same sign as d. The f stands for "floor". tdiv rounds q towards zero, and r will have the same sign as n. The t stands for "truncate". In all cases q and r will satisfy n=q*d+r, and r will satisfy 0<=abs(r)<abs(d). The q functions calculate only the quotient, the r functions only the remainder, and the qr functions calculate both. Note that for qr the same variable cannot be passed for both q and r, or results will be unpredictable. For the ui variants the return value is the remainder, and in fact returning the remainder is all the div_ui functions do. For tdiv and cdiv the remainder can be negative, so for those the return value is the absolute value of the remainder. For the 2exp variants the divisor is 2^b. These functions are implemented as right shifts and bit masks, but of course they round the same as the other functions. For positive n both mpz_fdiv_q_2exp and mpz_tdiv_q_2exp are simple bitwise right shifts. For negative n, mpz_fdiv_q_2exp is effectively an arithmetic right shift treating n as twos complement the same as the bitwise logical functions do, whereas mpz_tdiv_q_2exp effectively treats n as sign and magnitude. 

=cut
*/

function mpz_tdiv_q (var q, var n, var d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_tdiv_q");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_q");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_tdiv_q");
  using gmp.__gmpz_tdiv_q;
   __gmpz_tdiv_q(q, n, d);
}

function mpz_tdiv_r (var r, var n, var d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_tdiv_r");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_r");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_tdiv_r");
  using gmp.__gmpz_tdiv_r;
   __gmpz_tdiv_r(r, n, d);
}

function mpz_tdiv_qr (var q, var r, var n, var d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_tdiv_qr");
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_tdiv_qr");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_qr");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_tdiv_qr");
  using gmp.__gmpz_tdiv_qr;
   __gmpz_tdiv_qr(q, r, n, d);
}

function mpz_tdiv_q_ui (var q, var n, int d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_tdiv_q_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_q_ui");
  using gmp.__gmpz_tdiv_q_ui;
  return __gmpz_tdiv_q_ui(q, n, d);
}

function mpz_tdiv_r_ui (var r, var n, int d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_tdiv_r_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_r_ui");
  using gmp.__gmpz_tdiv_r_ui;
  return __gmpz_tdiv_r_ui(r, n, d);
}

function mpz_tdiv_qr_ui (var q, var r, var n, int d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_tdiv_qr_ui");
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_tdiv_qr_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_qr_ui");
  using gmp.__gmpz_tdiv_qr_ui;
  return __gmpz_tdiv_qr_ui(q, r, n, d);
}

function mpz_tdiv_ui (var n, int d) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_ui");
  using gmp.__gmpz_tdiv_ui;
  return __gmpz_tdiv_ui(n, d);
}

function mpz_tdiv_q_2exp (var q, var n, int b) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_tdiv_q_2exp");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_q_2exp");
  using gmp.__gmpz_tdiv_q_2exp;
   __gmpz_tdiv_q_2exp(q, n, b);
}

function mpz_tdiv_r_2exp (var r, var n, int b) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_tdiv_r_2exp");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_tdiv_r_2exp");
  using gmp.__gmpz_tdiv_r_2exp;
   __gmpz_tdiv_r_2exp(r, n, b);
}

/*
=head1 void mpz_mod (mpz_t r, mpz_t n, mpz_t d)

=head1 unsigned long int mpz_mod_ui (mpz_t r, mpz_t n, unsigned long int d)

Set r to n mod d. The sign of the divisor is ignored; the result is always non-negative. mpz_mod_ui is identical to mpz_fdiv_r_ui above, returning the remainder as well as setting r. See mpz_fdiv_ui above if only the return value is wanted. 

=cut
*/

function mpz_mod (var r, var n, var d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_mod");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_mod");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_mod");
  using gmp.__gmpz_mod;
   __gmpz_mod(r, n, d);
}

function mpz_mod_ui (var r, var n, int d) {
  if(!(r instanceof GMP.Integer))
    die("incorrect type for r in mpz_mod_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_mod_ui");
  using gmp.__gmpz_mod_ui;
  return __gmpz_mod_ui(r, n, d);
}

/*
=head1 void mpz_divexact (mpz_t q, mpz_t n, mpz_t d)

=head1 void mpz_divexact_ui (mpz_t q, mpz_t n, unsigned long d)

Set q to n/d. These functions produce correct results only when it is known in advance that d divides n. These routines are much faster than the other division functions, and are the best choice when exact division is known to occur, for example reducing a rational to lowest terms. 

=cut
*/

function mpz_divexact (var q, var n, var d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_divexact");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_divexact");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_divexact");
  using gmp.__gmpz_divexact;
   __gmpz_divexact(q, n, d);
}

function mpz_divexact_ui (var q, var n, int d) {
  if(!(q instanceof GMP.Integer))
    die("incorrect type for q in mpz_divexact_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_divexact_ui");
  using gmp.__gmpz_divexact_ui;
   __gmpz_divexact_ui(q, n, d);
}

/*
=head1 int mpz_divisible_p (mpz_t n, mpz_t d)

=head1 int mpz_divisible_ui_p (mpz_t n, unsigned long int d)

=head1 int mpz_divisible_2exp_p (mpz_t n, mp_bitcnt_t b)

Return non-zero if n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2^b. n is divisible by d if there exists an integer q satisfying n = q*d. Unlike the other division functions, d=0 is accepted and following the rule it can be seen that only 0 is considered divisible by 0. 

=cut
*/

function mpz_divisible_p (var n, var d) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_divisible_p");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_divisible_p");
  using gmp.__gmpz_divisible_p;
  return __gmpz_divisible_p(n, d);
}

function mpz_divisible_ui_p (var n, int d) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_divisible_ui_p");
  using gmp.__gmpz_divisible_ui_p;
  return __gmpz_divisible_ui_p(n, d);
}

function mpz_divisible_2exp_p (var n, int b) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_divisible_2exp_p");
  using gmp.__gmpz_divisible_2exp_p;
  return __gmpz_divisible_2exp_p(n, b);
}

/*
=head1 int mpz_congruent_p (mpz_t n, mpz_t c, mpz_t d)

=head1 int mpz_congruent_ui_p (mpz_t n, unsigned long int c, unsigned long int d)

=head1 int mpz_congruent_2exp_p (mpz_t n, mpz_t c, mp_bitcnt_t b)

Return non-zero if n is congruent to c modulo d, or in the case of mpz_congruent_2exp_p modulo 2^b. n is congruent to c mod d if there exists an integer q satisfying n = c + q*d. Unlike the other division functions, d=0 is accepted and following the rule it can be seen that n and c are considered congruent mod 0 only when exactly equal. 

=cut
*/

function mpz_congruent_p (var n, var c, var d) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_congruent_p");
  if(!(c instanceof GMP.Integer))
    die("incorrect type for c in mpz_congruent_p");
  if(!(d instanceof GMP.Integer))
    die("incorrect type for d in mpz_congruent_p");
  using gmp.__gmpz_congruent_p;
  return __gmpz_congruent_p(n, c, d);
}

function mpz_congruent_ui_p (var n, int c, int d) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_congruent_ui_p");
  using gmp.__gmpz_congruent_ui_p;
  return __gmpz_congruent_ui_p(n, c, d);
}

function mpz_congruent_2exp_p (var n, var c, int b) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_congruent_2exp_p");
  if(!(c instanceof GMP.Integer))
    die("incorrect type for c in mpz_congruent_2exp_p");
  using gmp.__gmpz_congruent_2exp_p;
  return __gmpz_congruent_2exp_p(n, c, b);
}

/*
=head1 void mpz_powm (mpz_t rop, mpz_t base, mpz_t exp, mpz_t mod)

=head1 void mpz_powm_ui (mpz_t rop, mpz_t base, unsigned long int exp, mpz_t mod)

Set rop to (base raised to exp) modulo mod. Negative exp is supported if an inverse base^-1 mod mod exists (see mpz_invert in Number Theoretic Functions). If an inverse doesn't exist then a divide by zero is raised. 

=cut
*/

function mpz_powm (var rop, var base, var exp, var mod) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_powm");
  if(!(base instanceof GMP.Integer))
    die("incorrect type for base in mpz_powm");
  if(!(exp instanceof GMP.Integer))
    die("incorrect type for exp in mpz_powm");
  if(!(mod instanceof GMP.Integer))
    die("incorrect type for mod in mpz_powm");
  using gmp.__gmpz_powm;
   __gmpz_powm(rop, base, exp, mod);
}

function mpz_powm_ui (var rop, var base, int exp, var mod) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_powm_ui");
  if(!(base instanceof GMP.Integer))
    die("incorrect type for base in mpz_powm_ui");
  if(!(mod instanceof GMP.Integer))
    die("incorrect type for mod in mpz_powm_ui");
  using gmp.__gmpz_powm_ui;
   __gmpz_powm_ui(rop, base, exp, mod);
}

/*
=head1 void mpz_powm_sec (mpz_t rop, mpz_t base, mpz_t exp, mpz_t mod)

Set rop to (base raised to exp) modulo mod. It is required that exp > 0 and that mod is odd. This function is designed to take the same time and have the same cache access patterns for any two same-size arguments, assuming that function arguments are placed at the same position and that the machine state is identical upon function entry. This function is intended for cryptographic purposes, where resilience to side-channel attacks is desired. 

=cut
*/

function mpz_powm_sec (var rop, var base, var exp, var mod) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_powm_sec");
  if(!(base instanceof GMP.Integer))
    die("incorrect type for base in mpz_powm_sec");
  if(!(exp instanceof GMP.Integer))
    die("incorrect type for exp in mpz_powm_sec");
  if(!(mod instanceof GMP.Integer))
    die("incorrect type for mod in mpz_powm_sec");
  using gmp.__gmpz_powm_sec;
   __gmpz_powm_sec(rop, base, exp, mod);
}

/*
=head1 void mpz_pow_ui (mpz_t rop, mpz_t base, unsigned long int exp)

=head1 void mpz_ui_pow_ui (mpz_t rop, unsigned long int base, unsigned long int exp)

Set rop to base raised to exp. The case 0^0 yields 1. 

=cut
*/

function mpz_pow_ui (var rop, var base, int exp) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_pow_ui");
  if(!(base instanceof GMP.Integer))
    die("incorrect type for base in mpz_pow_ui");
  using gmp.__gmpz_pow_ui;
   __gmpz_pow_ui(rop, base, exp);
}

function mpz_ui_pow_ui (var rop, int base, int exp) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_ui_pow_ui");
  using gmp.__gmpz_ui_pow_ui;
   __gmpz_ui_pow_ui(rop, base, exp);
}

/*
=head1 int mpz_root (mpz_t rop, mpz_t op, unsigned long int n)

Set rop to the truncated integer part of the nth root of op. Return non-zero if the computation was exact, i.e., if op is rop to the nth power. 

=cut
*/

function mpz_root (var rop, var op, int n) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_root");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_root");
  using gmp.__gmpz_root;
  return __gmpz_root(rop, op, n);
}

/*
=head1 void mpz_rootrem (mpz_t root, mpz_t rem, mpz_t u, unsigned long int n)

Set root to the truncated integer part of the nth root of u. Set rem to the remainder, u-root**n. 

=cut
*/

function mpz_rootrem (var root, var rem, var u, int n) {
  if(!(root instanceof GMP.Integer))
    die("incorrect type for root in mpz_rootrem");
  if(!(rem instanceof GMP.Integer))
    die("incorrect type for rem in mpz_rootrem");
  if(!(u instanceof GMP.Integer))
    die("incorrect type for u in mpz_rootrem");
  using gmp.__gmpz_rootrem;
   __gmpz_rootrem(root, rem, u, n);
}

/*
=head1 void mpz_sqrt (mpz_t rop, mpz_t op)

Set rop to the truncated integer part of the square root of op. 

=cut
*/

function mpz_sqrt (var rop, var op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_sqrt");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_sqrt");
  using gmp.__gmpz_sqrt;
   __gmpz_sqrt(rop, op);
}

/*
=head1 void mpz_sqrtrem (mpz_t rop1, mpz_t rop2, mpz_t op)

Set rop1 to the truncated integer part of the square root of op, like mpz_sqrt. Set rop2 to the remainder op-rop1*rop1, which will be zero if op is a perfect square. If rop1 and rop2 are the same variable, the results are undefined. 

=cut
*/

function mpz_sqrtrem (var rop1, var rop2, var op) {
  if(!(rop1 instanceof GMP.Integer))
    die("incorrect type for rop1 in mpz_sqrtrem");
  if(!(rop2 instanceof GMP.Integer))
    die("incorrect type for rop2 in mpz_sqrtrem");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_sqrtrem");
  using gmp.__gmpz_sqrtrem;
   __gmpz_sqrtrem(rop1, rop2, op);
}

/*
=head1 int mpz_perfect_power_p (mpz_t op)

Return non-zero if op is a perfect power, i.e., if there exist integers a and b, with b>1, such that op equals a raised to the power b. Under this definition both 0 and 1 are considered to be perfect powers. Negative values of op are accepted, but of course can only be odd perfect powers. 

=cut
*/

function mpz_perfect_power_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_perfect_power_p");
  using gmp.__gmpz_perfect_power_p;
  return __gmpz_perfect_power_p(op);
}

/*
=head1 int mpz_perfect_square_p (mpz_t op)

Return non-zero if op is a perfect square, i.e., if the square root of op is an integer. Under this definition both 0 and 1 are considered to be perfect squares. 

=cut
*/

function mpz_perfect_square_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_perfect_square_p");
  using gmp.__gmpz_perfect_square_p;
  return __gmpz_perfect_square_p(op);
}

/*
=head1 int mpz_probab_prime_p (mpz_t n, int reps)

Determine whether n is prime. Return 2 if n is definitely prime, return 1 if n is probably prime (without being certain), or return 0 if n is definitely composite. This function does some trial divisions, then some Miller-Rabin probabilistic primality tests. reps controls how many such tests are done, 5 to 10 is a reasonable number, more will reduce the chances of a composite being returned as "probably prime". Miller-Rabin and similar tests can be more properly called compositeness tests. Numbers which fail are known to be composite but those which pass might be prime or might be composite. Only a few composites pass, hence those which pass are considered probably prime. 

=cut
*/

function mpz_probab_prime_p (var n, int reps) {
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_probab_prime_p");
  using gmp.__gmpz_probab_prime_p;
  return __gmpz_probab_prime_p(n, reps);
}

/*
=head1 void mpz_nextprime (mpz_t rop, mpz_t op)

Set rop to the next prime greater than op. This function uses a probabilistic algorithm to identify primes. For practical purposes it's adequate, the chance of a composite passing will be extremely small. 

=cut
*/

function mpz_nextprime (var rop, var op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_nextprime");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_nextprime");
  using gmp.__gmpz_nextprime;
   __gmpz_nextprime(rop, op);
}

/*
=head1 void mpz_gcd (mpz_t rop, mpz_t op1, mpz_t op2)

Set rop to the greatest common divisor of op1 and op2. The result is always positive even if one or both input operands are negative. 

=cut
*/

function mpz_gcd (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_gcd");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_gcd");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_gcd");
  using gmp.__gmpz_gcd;
   __gmpz_gcd(rop, op1, op2);
}

/*
=head1 unsigned long int mpz_gcd_ui (mpz_t rop, mpz_t op1, unsigned long int op2)

Compute the greatest common divisor of op1 and op2. If rop is not NULL, store the result there. If the result is small enough to fit in an unsigned long int, it is returned. If the result does not fit, 0 is returned, and the result is equal to the argument op1. Note that the result will always fit if op2 is non-zero. 

=cut
*/

function mpz_gcd_ui (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_gcd_ui");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_gcd_ui");
  using gmp.__gmpz_gcd_ui;
  return __gmpz_gcd_ui(rop, op1, op2);
}

/*
=head1 void mpz_gcdext (mpz_t g, mpz_t s, mpz_t t, mpz_t a, mpz_t b)

Set g to the greatest common divisor of a and b, and in addition set s and t to coefficients satisfying a*s + b*t = g. The value in g is always positive, even if one or both of a and b are negative. The values in s and t are chosen such that abs(s) <= abs(b) and abs(t) <= abs(a). If t is NULL then that value is not computed. 

=cut
*/

function mpz_gcdext (var g, var s, var t, var a, var b) {
  if(!(g instanceof GMP.Integer))
    die("incorrect type for g in mpz_gcdext");
  if(!(s instanceof GMP.Integer))
    die("incorrect type for s in mpz_gcdext");
  if(!(t instanceof GMP.Integer))
    die("incorrect type for t in mpz_gcdext");
  if(!(a instanceof GMP.Integer))
    die("incorrect type for a in mpz_gcdext");
  if(!(b instanceof GMP.Integer))
    die("incorrect type for b in mpz_gcdext");
  using gmp.__gmpz_gcdext;
   __gmpz_gcdext(g, s, t, a, b);
}

/*
=head1 void mpz_lcm (mpz_t rop, mpz_t op1, mpz_t op2)

=head1 void mpz_lcm_ui (mpz_t rop, mpz_t op1, unsigned long op2)

Set rop to the least common multiple of op1 and op2. rop is always positive, irrespective of the signs of op1 and op2. rop will be zero if either op1 or op2 is zero. 

=cut
*/

function mpz_lcm (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_lcm");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_lcm");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_lcm");
  using gmp.__gmpz_lcm;
   __gmpz_lcm(rop, op1, op2);
}

function mpz_lcm_ui (var rop, var op1, int op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_lcm_ui");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_lcm_ui");
  using gmp.__gmpz_lcm_ui;
   __gmpz_lcm_ui(rop, op1, op2);
}

/*
=head1 int mpz_invert (mpz_t rop, mpz_t op1, mpz_t op2)

Compute the inverse of op1 modulo op2 and put the result in rop. If the inverse exists, the return value is non-zero and rop will satisfy 0 <= rop < op2. If an inverse doesn't exist the return value is zero and rop is undefined. 

=cut
*/

function mpz_invert (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_invert");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_invert");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_invert");
  using gmp.__gmpz_invert;
  return __gmpz_invert(rop, op1, op2);
}

/*
=head1 int mpz_jacobi (mpz_t a, mpz_t b)

Calculate the Jacobi symbol (a/b). This is defined only for b odd. 

=cut
*/

function mpz_jacobi (var a, var b) {
  if(!(a instanceof GMP.Integer))
    die("incorrect type for a in mpz_jacobi");
  if(!(b instanceof GMP.Integer))
    die("incorrect type for b in mpz_jacobi");
  using gmp.__gmpz_jacobi;
  return __gmpz_jacobi(a, b);
}

/*
=head1 int mpz_legendre (mpz_t a, mpz_t p)

Calculate the Legendre symbol (a/p). This is defined only for p an odd positive prime, and for such p it's identical to the Jacobi symbol. 

=cut
*/

function mpz_legendre (var a, var p) {
  if(!(a instanceof GMP.Integer))
    die("incorrect type for a in mpz_legendre");
  if(!(p instanceof GMP.Integer))
    die("incorrect type for p in mpz_legendre");
  using gmp.__gmpz_legendre;
  return __gmpz_legendre(a, p);
}

/*
=head1 int mpz_kronecker (mpz_t a, mpz_t b)

=head1 int mpz_kronecker_si (mpz_t a, long b)

=head1 int mpz_kronecker_ui (mpz_t a, unsigned long b)

=head1 int mpz_si_kronecker (long a, mpz_t b)

=head1 int mpz_ui_kronecker (unsigned long a, mpz_t b)

Calculate the Jacobi symbol (a/b) with the Kronecker extension (a/2)=(2/a) when a odd, or (a/2)=0 when a even. When b is odd the Jacobi symbol and Kronecker symbol are identical, so mpz_kronecker_ui etc can be used for mixed precision Jacobi symbols too. For more information see Henri Cohen section 1.4.2 (see References), or any number theory textbook. See also the example program demos/qcn.c which uses mpz_kronecker_ui. 

=cut
*/

function mpz_kronecker (var a, var b) {
  if(!(a instanceof GMP.Integer))
    die("incorrect type for a in mpz_kronecker");
  if(!(b instanceof GMP.Integer))
    die("incorrect type for b in mpz_kronecker");
  using gmp.__gmpz_kronecker;
  return __gmpz_kronecker(a, b);
}

function mpz_kronecker_si (var a, int b) {
  if(!(a instanceof GMP.Integer))
    die("incorrect type for a in mpz_kronecker_si");
  using gmp.__gmpz_kronecker_si;
  return __gmpz_kronecker_si(a, b);
}

function mpz_kronecker_ui (var a, int b) {
  if(!(a instanceof GMP.Integer))
    die("incorrect type for a in mpz_kronecker_ui");
  using gmp.__gmpz_kronecker_ui;
  return __gmpz_kronecker_ui(a, b);
}

function mpz_si_kronecker (int a, var b) {
  if(!(b instanceof GMP.Integer))
    die("incorrect type for b in mpz_si_kronecker");
  using gmp.__gmpz_si_kronecker;
  return __gmpz_si_kronecker(a, b);
}

function mpz_ui_kronecker (int a, var b) {
  if(!(b instanceof GMP.Integer))
    die("incorrect type for b in mpz_ui_kronecker");
  using gmp.__gmpz_ui_kronecker;
  return __gmpz_ui_kronecker(a, b);
}

/*
=head1 mp_bitcnt_t mpz_remove (mpz_t rop, mpz_t op, mpz_t f)

Remove all occurrences of the factor f from op and store the result in rop. The return value is how many such occurrences were removed. 

=cut
*/

function mpz_remove (var rop, var op, var f) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_remove");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_remove");
  if(!(f instanceof GMP.Integer))
    die("incorrect type for f in mpz_remove");
  using gmp.__gmpz_remove;
  return __gmpz_remove(rop, op, f);
}

/*
=head1 void mpz_fac_ui (mpz_t rop, unsigned long int op)

Set rop to op!, the factorial of op. 

=cut
*/

function mpz_fac_ui (var rop, int op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_fac_ui");
  using gmp.__gmpz_fac_ui;
   __gmpz_fac_ui(rop, op);
}

/*
=head1 void mpz_bin_ui (mpz_t rop, mpz_t n, unsigned long int k)

=head1 void mpz_bin_uiui (mpz_t rop, unsigned long int n, unsigned long int k)

Compute the binomial coefficient n over k and store the result in rop. Negative values of n are supported by mpz_bin_ui, using the identity bin(-n,k) = (-1)^k * bin(n+k-1,k), see Knuth volume 1 section 1.2.6 part G. 

=cut
*/

function mpz_bin_ui (var rop, var n, int k) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_bin_ui");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_bin_ui");
  using gmp.__gmpz_bin_ui;
   __gmpz_bin_ui(rop, n, k);
}

function mpz_bin_uiui (var rop, int n, int k) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_bin_uiui");
  using gmp.__gmpz_bin_uiui;
   __gmpz_bin_uiui(rop, n, k);
}

/*
=head1 void mpz_fib_ui (mpz_t fn, unsigned long int n)

=head1 void mpz_fib2_ui (mpz_t fn, mpz_t fnsub1, unsigned long int n)

mpz_fib_ui sets fn to to F[n], the n'th Fibonacci number. mpz_fib2_ui sets fn to F[n], and fnsub1 to F[n-1]. These functions are designed for calculating isolated Fibonacci numbers. When a sequence of values is wanted it's best to start with mpz_fib2_ui and iterate the defining F[n+1]=F[n]+F[n-1] or similar. 

=cut
*/

function mpz_fib_ui (var fn, int n) {
  if(!(fn instanceof GMP.Integer))
    die("incorrect type for fn in mpz_fib_ui");
  using gmp.__gmpz_fib_ui;
   __gmpz_fib_ui(fn, n);
}

function mpz_fib2_ui (var fn, var fnsub1, int n) {
  if(!(fn instanceof GMP.Integer))
    die("incorrect type for fn in mpz_fib2_ui");
  if(!(fnsub1 instanceof GMP.Integer))
    die("incorrect type for fnsub1 in mpz_fib2_ui");
  using gmp.__gmpz_fib2_ui;
   __gmpz_fib2_ui(fn, fnsub1, n);
}

/*
=head1 void mpz_lucnum_ui (mpz_t ln, unsigned long int n)

=head1 void mpz_lucnum2_ui (mpz_t ln, mpz_t lnsub1, unsigned long int n)

mpz_lucnum_ui sets ln to to L[n], the n'th Lucas number. mpz_lucnum2_ui sets ln to L[n], and lnsub1 to L[n-1]. These functions are designed for calculating isolated Lucas numbers. When a sequence of values is wanted it's best to start with mpz_lucnum2_ui and iterate the defining L[n+1]=L[n]+L[n-1] or similar. The Fibonacci numbers and Lucas numbers are related sequences, so it's never necessary to call both mpz_fib2_ui and mpz_lucnum2_ui. The formulas for going from Fibonacci to Lucas can be found in Lucas Numbers Algorithm, the reverse is straightforward too. 

=cut
*/

function mpz_lucnum_ui (var ln, int n) {
  if(!(ln instanceof GMP.Integer))
    die("incorrect type for ln in mpz_lucnum_ui");
  using gmp.__gmpz_lucnum_ui;
   __gmpz_lucnum_ui(ln, n);
}

function mpz_lucnum2_ui (var ln, var lnsub1, int n) {
  if(!(ln instanceof GMP.Integer))
    die("incorrect type for ln in mpz_lucnum2_ui");
  if(!(lnsub1 instanceof GMP.Integer))
    die("incorrect type for lnsub1 in mpz_lucnum2_ui");
  using gmp.__gmpz_lucnum2_ui;
   __gmpz_lucnum2_ui(ln, lnsub1, n);
}

/*
=head1 int mpz_cmp (mpz_t op1, mpz_t op2)

=head1 int mpz_cmp_d (mpz_t op1, double op2)

Compare op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, or a negative value if op1 < op2. mpz_cmp_ui and mpz_cmp_si are macros and will evaluate their arguments more than once. mpz_cmp_d can be called with an infinity, but results are undefined for a NaN. 

=cut
*/

function mpz_cmp (var op1, var op2) {
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_cmp");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_cmp");
  using gmp.__gmpz_cmp;
  return __gmpz_cmp(op1, op2);
}

function mpz_cmp_d (var op1, float op2) {
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_cmp_d");
  using gmp.__gmpz_cmp_d;
  return __gmpz_cmp_d(op1, op2);
}

/*
=head1 int mpz_cmpabs (mpz_t op1, mpz_t op2)

=head1 int mpz_cmpabs_d (mpz_t op1, double op2)

=head1 int mpz_cmpabs_ui (mpz_t op1, unsigned long int op2)

Compare the absolute values of op1 and op2. Return a positive value if abs(op1) > abs(op2), zero if abs(op1) = abs(op2), or a negative value if abs(op1) < abs(op2). mpz_cmpabs_d can be called with an infinity, but results are undefined for a NaN. 

=cut
*/

function mpz_cmpabs (var op1, var op2) {
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_cmpabs");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_cmpabs");
  using gmp.__gmpz_cmpabs;
  return __gmpz_cmpabs(op1, op2);
}

function mpz_cmpabs_d (var op1, float op2) {
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_cmpabs_d");
  using gmp.__gmpz_cmpabs_d;
  return __gmpz_cmpabs_d(op1, op2);
}

function mpz_cmpabs_ui (var op1, int op2) {
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_cmpabs_ui");
  using gmp.__gmpz_cmpabs_ui;
  return __gmpz_cmpabs_ui(op1, op2);
}

/*
=head1 void mpz_and (mpz_t rop, mpz_t op1, mpz_t op2)

Set rop to op1 bitwise-and op2. 

=cut
*/

function mpz_and (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_and");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_and");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_and");
  using gmp.__gmpz_and;
   __gmpz_and(rop, op1, op2);
}

/*
=head1 void mpz_ior (mpz_t rop, mpz_t op1, mpz_t op2)

Set rop to op1 bitwise inclusive-or op2. 

=cut
*/

function mpz_ior (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_ior");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_ior");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_ior");
  using gmp.__gmpz_ior;
   __gmpz_ior(rop, op1, op2);
}

/*
=head1 void mpz_xor (mpz_t rop, mpz_t op1, mpz_t op2)

Set rop to op1 bitwise exclusive-or op2. 

=cut
*/

function mpz_xor (var rop, var op1, var op2) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_xor");
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_xor");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_xor");
  using gmp.__gmpz_xor;
   __gmpz_xor(rop, op1, op2);
}

/*
=head1 void mpz_com (mpz_t rop, mpz_t op)

Set rop to the one's complement of op. 

=cut
*/

function mpz_com (var rop, var op) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_com");
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_com");
  using gmp.__gmpz_com;
   __gmpz_com(rop, op);
}

/*
=head1 mp_bitcnt_t mpz_popcount (mpz_t op)

If op>=0, return the population count of op, which is the number of 1 bits in the binary representation. If op<0, the number of 1s is infinite, and the return value is the largest possible mp_bitcnt_t. 

=cut
*/

function mpz_popcount (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_popcount");
  using gmp.__gmpz_popcount;
  return __gmpz_popcount(op);
}

/*
=head1 mp_bitcnt_t mpz_hamdist (mpz_t op1, mpz_t op2)

If op1 and op2 are both >=0 or both <0, return the hamming distance between the two operands, which is the number of bit positions where op1 and op2 have different bit values. If one operand is >=0 and the other <0 then the number of bits different is infinite, and the return value is the largest possible mp_bitcnt_t. 

=cut
*/

function mpz_hamdist (var op1, var op2) {
  if(!(op1 instanceof GMP.Integer))
    die("incorrect type for op1 in mpz_hamdist");
  if(!(op2 instanceof GMP.Integer))
    die("incorrect type for op2 in mpz_hamdist");
  using gmp.__gmpz_hamdist;
  return __gmpz_hamdist(op1, op2);
}

/*
=head1 mp_bitcnt_t mpz_scan0 (mpz_t op, mp_bitcnt_t starting_bit)

=head1 mp_bitcnt_t mpz_scan1 (mpz_t op, mp_bitcnt_t starting_bit)

Scan op, starting from bit starting_bit, towards more significant bits, until the first 0 or 1 bit (respectively) is found. Return the index of the found bit. If the bit at starting_bit is already what's sought, then starting_bit is returned. If there's no bit found, then the largest possible mp_bitcnt_t is returned. This will happen in mpz_scan0 past the end of a negative number, or mpz_scan1 past the end of a nonnegative number. 

=cut
*/

function mpz_scan0 (var op, int starting_bit) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_scan0");
  using gmp.__gmpz_scan0;
  return __gmpz_scan0(op, starting_bit);
}

function mpz_scan1 (var op, int starting_bit) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_scan1");
  using gmp.__gmpz_scan1;
  return __gmpz_scan1(op, starting_bit);
}

/*
=head1 void mpz_setbit (mpz_t rop, mp_bitcnt_t bit_index)

Set bit bit_index in rop. 

=cut
*/

function mpz_setbit (var rop, int bit_index) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_setbit");
  using gmp.__gmpz_setbit;
   __gmpz_setbit(rop, bit_index);
}

/*
=head1 void mpz_clrbit (mpz_t rop, mp_bitcnt_t bit_index)

Clear bit bit_index in rop. 

=cut
*/

function mpz_clrbit (var rop, int bit_index) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_clrbit");
  using gmp.__gmpz_clrbit;
   __gmpz_clrbit(rop, bit_index);
}

/*
=head1 void mpz_combit (mpz_t rop, mp_bitcnt_t bit_index)

Complement bit bit_index in rop. 

=cut
*/

function mpz_combit (var rop, int bit_index) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_combit");
  using gmp.__gmpz_combit;
   __gmpz_combit(rop, bit_index);
}

/*
=head1 int mpz_tstbit (mpz_t op, mp_bitcnt_t bit_index)

Test bit bit_index in op and return 0 or 1 accordingly. 

=cut
*/

function mpz_tstbit (var op, int bit_index) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_tstbit");
  using gmp.__gmpz_tstbit;
  return __gmpz_tstbit(op, bit_index);
}

/*
=head1 void mpz_urandomb (mpz_t rop, gmp_randstate_t state, mp_bitcnt_t n)

Generate a uniformly distributed random integer in the range 0 to 2^n-1, inclusive. The variable state must be initialized by calling one of the gmp_randinit functions (Random State Initialization) before invoking this function. 

=cut
*/

function mpz_urandomb (var rop, var state, int n) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_urandomb");
  using gmp.__gmpz_urandomb;
   __gmpz_urandomb(rop, state, n);
}

/*
=head1 void mpz_urandomm (mpz_t rop, gmp_randstate_t state, mpz_t n)

Generate a uniform random integer in the range 0 to n-1, inclusive. The variable state must be initialized by calling one of the gmp_randinit functions (Random State Initialization) before invoking this function. 

=cut
*/

function mpz_urandomm (var rop, var state, var n) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_urandomm");
  if(!(n instanceof GMP.Integer))
    die("incorrect type for n in mpz_urandomm");
  using gmp.__gmpz_urandomm;
   __gmpz_urandomm(rop, state, n);
}

/*
=head1 void mpz_rrandomb (mpz_t rop, gmp_randstate_t state, mp_bitcnt_t n)

Generate a random integer with long strings of zeros and ones in the binary representation. Useful for testing functions and algorithms, since this kind of random numbers have proven to be more likely to trigger corner-case bugs. The random number will be in the range 0 to 2^n-1, inclusive. The variable state must be initialized by calling one of the gmp_randinit functions (Random State Initialization) before invoking this function. 

=cut
*/

function mpz_rrandomb (var rop, var state, int n) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_rrandomb");
  using gmp.__gmpz_rrandomb;
   __gmpz_rrandomb(rop, state, n);
}

/*
=head1 void mpz_random (mpz_t rop, mp_size_t max_size)

Generate a random integer of at most max_size limbs. The generated random number doesn't satisfy any particular requirements of randomness. Negative random numbers are generated when max_size is negative. This function is obsolete. Use mpz_urandomb or mpz_urandomm instead. 

=cut
*/

function mpz_random (var rop, int max_size) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_random");
  using gmp.__gmpz_random;
   __gmpz_random(rop, max_size);
}

/*
=head1 void mpz_random2 (mpz_t rop, mp_size_t max_size)

Generate a random integer of at most max_size limbs, with long strings of zeros and ones in the binary representation. Useful for testing functions and algorithms, since this kind of random numbers have proven to be more likely to trigger corner-case bugs. Negative random numbers are generated when max_size is negative. This function is obsolete. Use mpz_rrandomb instead. 

=cut
*/

function mpz_random2 (var rop, int max_size) {
  if(!(rop instanceof GMP.Integer))
    die("incorrect type for rop in mpz_random2");
  using gmp.__gmpz_random2;
   __gmpz_random2(rop, max_size);
}

/*
=head1 int mpz_fits_ulong_p (mpz_t op)

=head1 int mpz_fits_slong_p (mpz_t op)

=head1 int mpz_fits_uint_p (mpz_t op)

=head1 int mpz_fits_sint_p (mpz_t op)

=head1 int mpz_fits_ushort_p (mpz_t op)

=head1 int mpz_fits_sshort_p (mpz_t op)

Return non-zero iff the value of op fits in an unsigned long int, signed long int, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, return zero. 

=cut
*/

function mpz_fits_ulong_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_fits_ulong_p");
  using gmp.__gmpz_fits_ulong_p;
  return __gmpz_fits_ulong_p(op);
}

function mpz_fits_slong_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_fits_slong_p");
  using gmp.__gmpz_fits_slong_p;
  return __gmpz_fits_slong_p(op);
}

function mpz_fits_uint_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_fits_uint_p");
  using gmp.__gmpz_fits_uint_p;
  return __gmpz_fits_uint_p(op);
}

function mpz_fits_sint_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_fits_sint_p");
  using gmp.__gmpz_fits_sint_p;
  return __gmpz_fits_sint_p(op);
}

function mpz_fits_ushort_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_fits_ushort_p");
  using gmp.__gmpz_fits_ushort_p;
  return __gmpz_fits_ushort_p(op);
}

function mpz_fits_sshort_p (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_fits_sshort_p");
  using gmp.__gmpz_fits_sshort_p;
  return __gmpz_fits_sshort_p(op);
}

/*
=head1 size_t mpz_sizeinbase (mpz_t op, int base)

Return the size of op measured in number of digits in the given base. base can vary from 2 to 62. The sign of op is ignored, just the absolute value is used. The result will be either exact or 1 too big. If base is a power of 2, the result is always exact. If op is zero the return value is always 1. This function can be used to determine the space required when converting op to a string. The right amount of allocation is normally two more than the value returned by mpz_sizeinbase, one extra for a minus sign and one for the null-terminator. It will be noted that mpz_sizeinbase(op,2) can be used to locate the most significant 1 bit in op, counting from 1. (Unlike the bitwise functions which start from 0, See Logical and Bit Manipulation Functions.) 

=cut
*/

function mpz_sizeinbase (var op, int base) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_sizeinbase");
  using gmp.__gmpz_sizeinbase;
  return __gmpz_sizeinbase(op, base);
}

/*
=head1 void mpz_array_init (mpz_t integer_array, mp_size_t array_size, mp_size_t fixed_num_bits)

This is a special type of initialization. Fixed space of fixed_num_bits is allocated to each of the array_size integers in integer_array. There is no way to free the storage allocated by this function. Don't call mpz_clear! The integer_array parameter is the first mpz_t in the array. For example,           mpz_t  arr[20000];
          mpz_array_init (arr[0], 20000, 512);
     This function is only intended for programs that create a large number of integers and need to reduce memory usage by avoiding the overheads of allocating and reallocating lots of small blocks. In normal programs this function is not recommended. The space allocated to each integer by this function will not be automatically increased, unlike the normal mpz_init, so an application must ensure it is sufficient for any value stored. The following space requirements apply to various routines, mpz_abs, mpz_neg, mpz_set, mpz_set_si and mpz_set_ui need room for the value they store. mpz_add, mpz_add_ui, mpz_sub and mpz_sub_ui need room for the larger of the two operands, plus an extra mp_bits_per_limb. mpz_mul, mpz_mul_ui and mpz_mul_ui need room for the sum of the number of bits in their operands, but each rounded up to a multiple of mp_bits_per_limb. mpz_swap can be used between two array variables, but not between an array and a normal variable. For other functions, or if in doubt, the suggestion is to calculate in a regular mpz_init variable and copy the result to an array variable with mpz_set. 

=cut
*/

function mpz_array_init (var integer_array, int array_size, int fixed_num_bits) {
  if(!(integer_array instanceof GMP.Integer))
    die("incorrect type for integer_array in mpz_array_init");
  using gmp.__gmpz_array_init;
   __gmpz_array_init(integer_array, array_size, fixed_num_bits);
}

/*
=head1 mp_limb_t mpz_getlimbn (mpz_t op, mp_size_t n)

Return limb number n from op. The sign of op is ignored, just the absolute value is used. The least significant limb is number 0. mpz_size can be used to find how many limbs make up op. mpz_getlimbn returns zero if n is outside the range 0 to mpz_size(op)-1. 

=cut
*/

function mpz_getlimbn (var op, int n) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_getlimbn");
  using gmp.__gmpz_getlimbn;
  return __gmpz_getlimbn(op, n);
}

/*
=head1 size_t mpz_size (mpz_t op)

Return the size of op measured in number of limbs. If op is zero, the returned value will be zero. 

=cut
*/

function mpz_size (var op) {
  if(!(op instanceof GMP.Integer))
    die("incorrect type for op in mpz_size");
  using gmp.__gmpz_size;
  return __gmpz_size(op);
}

