$include_const 'datatypes.pasm';

function load[anon,load]() {
  load_bytecode('GMP/raw.pbc');
  load_bytecode('GMP/Common.pbc');
}

namespace GMP {
  class Integer {
    var ptr;

    function Integer(var init[optional], int has_init[opt_flag]) {
      using GMP.Common.gmpz_t;
      var t = gmpz_t();
      var ptr = self.ptr = t.alloc();

      if (has_init) {
        if (init instanceof 'String') {
          using GMP.Raw.__gmpz_init;
          using mpz_set_str;
          # ideally use __gmpz_init_set_str
          __gmpz_init(ptr);
          mpz_set_str(self, string(init), 10);
          self.ptr = ptr;
        }
        else if (init instanceof 'Integer') {
          using GMP.Raw.__gmpz_init;
          using mpz_set_str;
          # ideally use __gmpz_init_set_str
          __gmpz_init(ptr);
          mpz_set_str(self, string(init), 10);
          self.ptr = ptr;
        }
        else {
          throw Error("incorrect type init for Integer constructor");
        }
      } else {
        using GMP.Raw.__gmpz_init;
        __gmpz_init(ptr);
        self.ptr = ptr;
      }
    }

    function destroy[vtable('destroy')]() {
      if(self.ptr != null) {
        var ptr  = self.ptr;
        self.ptr = null;
        using GMP.Raw.__gmpz_clear;
        __gmpz_clear(ptr);
      }
    }

    function get_string[vtable]() {
      return mpz_get_str("", 10, self);
    }

    function get_integer[vtable]() {
      return mpz_get_si(self);
    }

    function get_number[vtable]() {
      return mpz_get_d(self);
    }

    function get_bool[vtable]() {
      return mpz_get_ui(self);
    }

    function set_integer_native[vtable](int value) {
      mpz_set_si(self, value);
    }

    function set_number_native[vtable](float value) {
      mpz_set_d(self, value);
    }

    function set_string_native[vtable](string value) {
      int i = mpz_set_str(self, value, 10);
    }

    /* vtable overrides to implement
    function add[vtable](var value, var dest) {
      var ret = new GMP.Integer();
      mpz_add(ret, value, dest);
      return ret;
    }

    function add_int[vtable](int value, var dest) {
      return 
    }

    function add_float[vtable](float value, var dest) {
      return 
    }

    function i_add(var value) {

    }

    function i_add_int(int value) {

    }

    function i_add_float(float value) {

    }

    function subtract[vtable](var value, var dest) {
      return 
    }

    function subtract_int[vtable](int value, var dest) {
      return 
    }

    function subtract_float[vtable](float value, var dest) {
      return 
    }

    function i_subtract(var value) {

    }

    function i_subtract_int(int value) {

    }

    function i_subtract_float(float value) {

    }

    function multiply[vtable](var value, var dest) {
      return 
    }

    function multiply_int[vtable](int value, var dest) {
      return 
    }

    function multiply_float[vtable](float value, var dest) {
      return 
    }

    function i_multiply(var value) {

    }

    function i_multiply_int(int value) {

    }

    function i_multiply_float(float value) {

    }

    function divide[vtable](var value, var dest) {
      return 
    }

    function divide_int[vtable](var value, var dest) {
      return 
    }

    function divide_float[vtable](varalue, var dest) {
      return 
    }

    function i_divide(var value) {

    }

    function i_divide_int(int value) {

    }

    function i_divide_float(float value) {

    }

    function floor_divide[vtable](var value, var dest) {
      return 
    }

    function floor_divide_int[vtable](int value, var dest) {
      return 
    }

    function floor_divide_float[vtable](float value, var dest) {
      return 
    }

    function i_floor_divide(var value) {

    }

    function i_floor_divide_int(int value) {

    }

    function i_floor_divide_float(float value) {

    }

    function modulus[vtable](var value, var dest) {
      return 
    }

    function modulus_int[vtable](int value, var dest) {
      return 
    }

    function modulus_float[vtable](float value, var dest) {
      return 
    }

    function i_modulus(var value) {

    }

    function i_modulus_int(int value) {

    }

    function i_modulus_float(float value) {

    }

    function increment() {

    }

    function decrement() {

    }

    function absolute[vtable](var dest) {
      return
    }

    function i_absolute() {

    }

    function neg(var dest) {
      return
    }

    function i_neg() {

    }

    function is_equal(var value) {
      return
    }

    function is_equal_num(var value) {
      return
    }

    function is_equal_string(var value) {
      return
    }

    function is_same(var value) {
      return
    }

    function cmp(var value) {
      return
    }

    function cmp_num(var value) {
      return
    }

    function cmp_string(var value) {
      return
    }

    */
  }
}

/*
=head1 int mpz_sgn (mpz_t op)

Return +1 if op > 0, 0 if op = 0, and -1 if op < 0. This function is actually implemented as a macro. It evaluates its argument multiple times. 

=cut
*/

function mpz_sgn (var op) {
  if(!(op instanceof GMP.Integer))
    throw Error("incorrect type for op in mpz_sgn");
  int i = mpz_cmp_ui(op, 0);
  if (i > 0)
    return 1;
  if (i < 0)
    return -1;
  return 0;
}

/*
=head1 int mpz_odd_p (mpz_t op)

=head1 int mpz_even_p (mpz_t op)

Determine whether op is odd or even, respectively. Return non-zero if yes, zero if no. These macros evaluate their argument more than once. 

=cut
*/

function mpz_odd_p (var op) {
  if(!(op instanceof GMP.Integer))
    throw Error("incorrect type for op in mpz_odd_p");
  return mpz_tstbit(op, 0);
}

function mpz_even_p (var op) {
  if(!(op instanceof GMP.Integer))
    throw Error("incorrect type for op in mpz_even_p");
  return !mpz_tstbit(op, 0);
}

